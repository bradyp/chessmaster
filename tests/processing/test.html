<!-- 
http://processing.org/learning/2darray/
-->
<!DOCTYPE html>
<html>
  <head>
    <style>
        *{
            margin: 0px 0px 0px 0px;
            padding: 0px 0px 0px 0px;
        }
        canvas {
            margin-left: auto;
            margin-right: auto;
            display: block;
        }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
    <script src="processing-1.4.1.js"></script>
        <body>
            <select id="pieces">
                <option>Black Rook L</option>
                <option>Black Rook R</option>
                <option>Black Knight L</option>
                <option>Black Knight R</option>
                <option>Black Bishop L</option>
                <option>Black Bishop R</option>
                <option>Black Queen</option>
                <option>Black King</option>
                <option>Black Pawn 1</option>
                <option>Black Pawn 2</option>
                <option>Black Pawn 3</option>
                <option>Black Pawn 4</option>
                <option>Black Pawn 5</option>
                <option>Black Pawn 6</option>
                <option>Black Pawn 7</option>
                <option>Black Pawn 8</option>

                <option>White Rook L</option>
                <option>White Rook R</option>
                <option>White Knight L</option>
                <option>White Knight R</option>
                <option>White Bishop L</option>
                <option>White Bishop R</option>
                <option>White Queen</option>
                <option>White King</option>
                <option>White Pawn 1</option>
                <option>White Pawn 2</option>
                <option>White Pawn 3</option>
                <option>White Pawn 4</option>
                <option>White Pawn 5</option>
                <option>White Pawn 6</option>
                <option>White Pawn 7</option>
                <option>White Pawn 8</option>

            </select>
            
            <script type="application/processing">
                // 2D Array of objects
                Cell[][] grid;
                HScrollbar Hbar;
                var history = {};
                int states_length = 0;
                int inc_width = 0;
                int current_state = 0;
                string piece = "";
                // Number of columns and rows in the grid
                int cols = 8;
                int rows = 8;
                
                void setup() {
                    size(screen.height - 199 - screen.height% 8,screen.height - 149 - screen.height % 8);
                    background(0);
                    grid = new Cell[cols][rows];
                    stroke(0);
                    for (int i = 0; i < cols; i++) {
                        for (int j = 0; j < rows; j++) {
                            scale = int(width / 8);
                            grid[i][j] = new Cell(i * scale,j * scale,scale,scale,0);
                        }
                    }
                    Hbar = new HScrollbar(0, width+25, width, 50, 10);
                    piece = "bR1";
                    load_file(piece);
                    
                }
                
                void update(){
                    stroke(0);
                    for (int i = 0; i < cols; i++) {
                        for (int j = 0; j < rows; j++) {
                            grid[i][j].display();
                        }
                    }
                    if (states_length > 0){//changes color for each square according to probs known
                        for (var entry in history[current_state.toString()]){
                            place = map(entry);
                            grid[place[0]][place[1]].setColor(255 * history[current_state.toString()][entry]);
                            grid[place[0]][place[1]].display();
                        }
                    }
                }
                void draw() {
                    inc_width = width / states_length;
                    Hbar.update();
                    Hbar.display();
                    Hbar.setPos(current_state * inc_width);
                    update();
                    
                    if (piece != get_id(pieces.options[pieces.selectedIndex].text)){ //new piece selected
                        piece = get_id(pieces.options[pieces.selectedIndex].text);
                        load_file(piece);
                    }
                }
                
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                class Cell {
                    // A cell object knows about its location in the grid as well as its size with the variables x,y,w,h.
                    float x,y;   // x,y location
                    float w,h;   // width and height
                    Color c; // angle for oscillating brightness
                    
                    // Cell Constructor
                    Cell(float tempX, float tempY, float tempW, float tempH, Color tempC) {
                        x = tempX;
                        y = tempY;
                        w = tempW;
                        h = tempH;
                        c = tempC;
                    } 
                    
                    void display() {
                        fill(255 - c);
                        rect(x,y,w,h);
                    }
                    
                    void setColor(c_){c = c_;}
                   
                }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                class HScrollbar {
                    int swidth, sheight;    // width and height of bar
                    float xpos, ypos;       // x and y position of bar
                    float spos, newspos;    // x position of slider
                    float sposMin, sposMax; // max and min values of slider
                    int loose;              // how loose/heavy
                    boolean over;           // is the mouse over the slider?
                    boolean locked;
                    float ratio;
                    
                    HScrollbar (float xp, float yp, int sw, int sh, int l) {
                        swidth = sw;
                        sheight = sh;
                        int widthtoheight = sw - sh;
                        ratio = (float)sw / (float)widthtoheight;
                        xpos = xp;
                        ypos = yp-sheight/2;
                        spos = xpos;
                        newspos = spos;
                        sposMin = xpos;
                        sposMax = xpos + swidth - sheight;
                        loose = l;
                        
                    }
                    
                    void update() {
                        if (overEvent()) {
                            over = true;
                        } else {
                            over = false;
                        }
                        if (mousePressed && over) {
                            locked = true;
                        }
                        if (!mousePressed) {
                            locked = false;
                        }
                        if (locked) {
                            newspos = constrain(mouseX-sheight/2, sposMin, sposMax);
                        }
                        if (abs(newspos - spos) > 1) {
                            spos = spos + (newspos-spos)/loose;
                        }
                    }
                    
                    float constrain(float val, float minv, float maxv) {
                        return min(max(val, minv), maxv);
                    }
                    
                    boolean overEvent() {
                        if (mouseX > xpos && mouseX < xpos+swidth &&
                            mouseY > ypos && mouseY < ypos+sheight) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                    
                    void display() {
                        noStroke();
                        fill(204);
                        rect(xpos, ypos, swidth, sheight);
                        if (over || locked) {
                            fill(0, 0, 0);
                        } else {
                            fill(102, 102, 102);
                        }
                        rect(spos, ypos, sheight, sheight);
                    }
                    
                    int getPos() {
                        return int(spos * ratio);
                    }
                    
                    void setPos(int len) {
                        newspos = len/ratio;
                    }
                }/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                void mouseClicked() {
                    i_ = find(mouseX);
                    j_ = find(mouseY);
                    if (i_ == -1 || j_ == -1) {return;} //doesn't do anything if click isn't on board                    
                    if (states_length >= 0){
                        if (mouseButton == LEFT) {
                            if (current_state < states_length){
                                current_state += 1;
                                Hbar.setPos(current_state * inc_width);
                            }
                        }
                        else if (mouseButton == RIGHT){
                            if (current_state > 0) {
                                current_state -= 1;
                                Hbar.setPos(current_state * inc_width);
                            }
                        }
                    }
                    else{
                        alert("invalid data for " + piece);
                        alert("stored " + piece);
                        alert("actual " + get_id(pieces.options[pieces.selectedIndex].text));
                        alert(piece != get_id(pieces.options[pieces.selectedIndex].text));
                    }
                }
                
                int find(pos){
                    scale = width/8;
                    for (int i=1; i<=8; i++){
                        if ((pos < scale * i) && (pos >= scale * (i-1))){
                            return i-1;
                        }
                    }
                    return -1;
                }
                
                int[] map(string position) {
                    x = (int)position.charCodeAt(0) - 65;
                    y = 8 - parseInt(position[1],10);
                    return [x,y]
                }
                string get_id(string id){
                    output = '';
                    output += id.charAt(0).toLowerCase();
                    last = id.charAt(id.length - 1);
                    if (id[6] == "K" && (last == "L" || last == "R")){output += "N";}
                    else {output += id[6]}
                    
                    if (last == "n" || last == "g"){output += output[1];}
                    else if (last == "L"){output += "1";}
                    else if (last == "R"){output += "2";}
                    else {output += last;}
                    println("HOLA!");
                    return output;
                }
                void load_file(piece_id){
                    alert("File Loaded");
                    $.getJSON( "../counting/" + piece_id + ".json", function(data){
                              history = data;
                              states_length = Object.keys(data).length;
//                              })
//                    .error(function(){
//                           console.log("debug2 - error");
                           });

                    current_state = 0;
                    Hbar.setPos(0);
                }
      </script>
            <canvas>Please update your browser</canvas>
    </body>
  </html>
