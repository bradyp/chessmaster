<!-- 
http://processing.org/learning/2darray/
-->
<!DOCTYPE html>
<html>
  <head>
    <style>
      *{
        margin: 0px 0px 0px 0px;
        padding: 0px 0px 0px 0px;
      }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
    <script src="processing-1.4.1.js"></script>
        <body>
            <script type="application/processing">
                // 2D Array of objects
                Cell[][] grid;
                HScrollbar Hbar;
                var history;
                int states_length = 0;
                int inc_width = 0;
                int current_state = 0;
                // Number of columns and rows in the grid
                int cols = 8;
                int rows = 8;
                
                void setup() {
                    size(screen.height - 200,screen.height - 150);
                    background(0);
                    grid = new Cell[cols][rows];
                    stroke(0);
                    for (int i = 0; i < cols; i++) {
                        for (int j = 0; j < rows; j++) {
                            scale = width /8;
                            grid[i][j] = new Cell(i * scale,j * scale,scale,scale,0);
                        }
                    }
                    Hbar = new HScrollbar(0, width+25, width, 50, 10);
                }
                
                void draw() {
                    stroke(0);
                    inc_width = width / states_length;
                    for (int i = 0; i < cols; i++) {
                        for (int j = 0; j < rows; j++) {
                    
                            grid[i][j].display();
                        }
                    }
                    
                    /*for (var entry in history[current_state.toString()]){
                        place = map(entry);
                        grid[place[0]][place[1]].setColor(255 * history[current_state.toString()][entry]);
                        grid[place[0]][place[1]].display();
                    }*/
                    
                    Hbar.update();
                    Hbar.display();
                    Hbar.setPos(current_state * inc_width);
                }
                
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                class Cell {
                    // A cell object knows about its location in the grid as well as its size with the variables x,y,w,h.
                    float x,y;   // x,y location
                    float w,h;   // width and height
                    Color c; // angle for oscillating brightness
                    
                    // Cell Constructor
                    Cell(float tempX, float tempY, float tempW, float tempH, Color tempC) {
                        x = tempX;
                        y = tempY;
                        w = tempW;
                        h = tempH;
                        c = tempC;
                    } 
                    
                    void display() {
                        fill(255 - c);
                        rect(x,y,w,h);
                    }
                    
                    void setColor(c_){c = c_;}
                   
                }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                class HScrollbar {
                    int swidth, sheight;    // width and height of bar
                    float xpos, ypos;       // x and y position of bar
                    float spos, newspos;    // x position of slider
                    float sposMin, sposMax; // max and min values of slider
                    int loose;              // how loose/heavy
                    boolean over;           // is the mouse over the slider?
                    boolean locked;
                    float ratio;
                    
                    HScrollbar (float xp, float yp, int sw, int sh, int l) {
                        swidth = sw;
                        sheight = sh;
                        int widthtoheight = sw - sh;
                        ratio = (float)sw / (float)widthtoheight;
                        xpos = xp;
                        ypos = yp-sheight/2;
                        spos = xpos;
                        newspos = spos;
                        sposMin = xpos;
                        sposMax = xpos + swidth - sheight;
                        loose = l;
                        
                    }
                    
                    void update() {
                        if (overEvent()) {
                            over = true;
                        } else {
                            over = false;
                        }
                        if (mousePressed && over) {
                            locked = true;
                        }
                        if (!mousePressed) {
                            locked = false;
                        }
                        if (locked) {
                            newspos = constrain(mouseX-sheight/2, sposMin, sposMax);
                        }
                        if (abs(newspos - spos) > 1) {
                            spos = spos + (newspos-spos)/loose;
                        }
                    }
                    
                    float constrain(float val, float minv, float maxv) {
                        return min(max(val, minv), maxv);
                    }
                    
                    boolean overEvent() {
                        if (mouseX > xpos && mouseX < xpos+swidth &&
                            mouseY > ypos && mouseY < ypos+sheight) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                    
                    void display() {
                        noStroke();
                        fill(204);
                        rect(xpos, ypos, swidth, sheight);
                        if (over || locked) {
                            fill(0, 0, 0);
                        } else {
                            fill(102, 102, 102);
                        }
                        rect(spos, ypos, sheight, sheight);
                        
                        
                    }
                    
                    int getPos() {
                        // Convert spos to be values between
                        // 0 and the total width of the scrollbar
                        return int(spos * ratio);
                    }
                    
                    void setPos(int len) {
                        newspos = len/ratio;
                    }
                }/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                void mouseClicked() {
                    i_ = find(mouseX);
                    j_ = find(mouseY);
                    if (i_ == -1 || j_ == -1) {return;} //doesn't do anything if click isn't on board
                    if (Hbar.getPos() == 0 && (j_ < 2 || j_ > 5)) {
                        $.getJSON( "../counting/bKK.json", function(data){history = data;});
                        states_length = Object.keys(history).length;
                        current_state = 1;

                        for (int i=0; i<8; i++){
                            for (int j=0; j<8; j++){
                                break;
                            }
                        }
                    }
                    else if (states_length > 0){
                        if (mouseButton == LEFT) {
                            if (current_state < states_length){
                                current_state += 1;
                                Hbar.setPos(current_state * inc_width);
                            }
                        }
                        else if (mouseButton == RIGHT){
                            if (current_state > 0) {
                                current_state -= 1;
                                Hbar.setPos(current_state * inc_width);
                            }
                        }
                    }
                }
                
                int find(pos){
                    scale = width/8;
                    for (int i=1; i<=8; i++){
                        if ((pos < scale * i) && (pos >= scale * (i-1))){
                            return i-1;
                        }
                    }
                    return -1;
                }
                
                int[] map(string position) {
                    x = (int)position.charCodeAt(0) - 65;
                    y = 8 - parseInt(position[1],10);
                    return [x,y]
                }

      </script>
            <canvas width="500" height="500" ></canvas>
    </body>
  </html>
